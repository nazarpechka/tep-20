#include <iostream>

class RefCounter {
 public:
  RefCounter() { m_count = 0; };

  int inc() { return ++m_count; };
  int dec() { return --m_count; };
  int get() { return m_count; };

 private:
  int m_count;
};

template <typename T>
class SharedPointer {
 public:
  SharedPointer(T* pointer);
  SharedPointer(const SharedPointer<T>& other);
  SharedPointer(SharedPointer<T>&& other);
  ~SharedPointer();

  SharedPointer<T>& operator=(const SharedPointer<T>& other);

  T& operator*();
  T* operator->();

  void setCounter(RefCounter* counter);

  template <typename E>
  SharedPointer<E> dyn_cast();

 private:
  T* m_pointer;
  RefCounter* m_counter;
};

template <typename T>
SharedPointer<T>::SharedPointer(T* pointer)
    : m_pointer(pointer), m_counter(new RefCounter()) {
  m_counter->inc();
}

template <typename T>
SharedPointer<T>::SharedPointer(const SharedPointer<T>& other)
    : m_pointer(other.m_pointer), m_counter(other.m_counter) {
  std::cout << "copy ctor\n";
  m_counter->inc();
}

template <typename T>
SharedPointer<T>::SharedPointer(SharedPointer&& other)
    : m_pointer(other.m_pointer), m_counter(other.m_counter) {
  std::cout << "move ctor\n";
  other.m_pointer = nullptr;
  other.m_counter = new RefCounter();
}

template <typename T>
SharedPointer<T>::~SharedPointer() {
  if (m_counter->dec() < 1) {
    delete m_pointer;
    delete m_counter;
  }
}

template <typename T>
SharedPointer<T>& SharedPointer<T>::operator=(const SharedPointer<T>& other) {
  if (this != &other) {
    if (m_counter->dec() == 0) {
      delete m_pointer;
      delete m_counter;
    }

    m_pointer = other.m_pointer;
    m_counter = other.m_counter;
    m_counter->inc();
  }

  return *this;
}

template <typename T>
T* SharedPointer<T>::operator->() {
  return m_pointer;
}

template <typename T>
void SharedPointer<T>::setCounter(RefCounter* counter) {
  delete m_counter;
  m_counter = counter;
}

template <typename T>
T& SharedPointer<T>::operator*() {
  return *m_pointer;
}

template <typename T>
template <typename E>
SharedPointer<E> SharedPointer<T>::dyn_cast() {
  SharedPointer<E> cast_ptr(dynamic_cast<E*>(m_pointer));
  cast_ptr.setCounter(m_counter);
  m_counter->inc();
  return cast_ptr;
}

class A {
 public:
  A() { std::cout << "Class A c'tor\n"; }

  virtual ~A() { std::cout << "Class A d'tor\n"; }

  void print() { std::cout << "I'm class A\n"; }
};

class B : public A {
 public:
  B() { std::cout << "Class B c'tor\n"; }

  ~B() { std::cout << "Class B d'tor\n"; }

  void print() { std::cout << "I'm class B\n"; }
};

int main() {
  SharedPointer<B> ptr(new B());
  ptr->print();
  SharedPointer<A> casted = ptr.dyn_cast<A>();
  casted->print();

  return 0;
}